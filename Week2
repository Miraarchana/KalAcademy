Week 2 - Stacks and Queues
Queue : FIFO
Stack : LIFO
 - Both can be implemented using array and linked list
 - No indexing, we can access only on top and bottom elements for queue and only top for stack

Check for implementing Queue using array in referencesource.microsoft.com for C#

Week 2 Assessments:
1. Find the missing paranthesis in the given expression 2*(3+5(sabcd)

Expression string can be converted to a character array and then look for the missing paranthesis
Approach1: Counter approach o(n) time
 - check every character in the string for left paranthesis or right paranthesis
   - if the char is '(' - increment openCounter
   - else if the  char is ')' - increment closeCounter
   - else if it is a number or variable continue checking the next char
 - if value of openCounter == closeCounter, there is no missing paranthesis
 - if value of openCounter > closeCounter, there is (openCounter-closeCounter) closeCounters missing
 - if value of openCounter < closeCounter, there is (closeCOunter-openCounter) openCounters missing
limitation: if the expression contains more than one set of paranthesis like [] or{} we cannot use this approach

Approach2: Using Stack



-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
4. Implement Queue using Stacks

- for implementing Queue, enqueue must add element to the top of Stack and dequeue must remove element from bottom of stack.

Approach1: Using 2 Stacks (Enqueue does the work of maintaing the LIFO pointers)
enqueue:
  - If stack1 is empty- push element to stack1
  - If stack1 is not empty
    - copy all elements from stack1 to stack2
    - push new element to stack1
    - push all elements back from stack2 to stack1
dequeue:
  - If stack1 is empty - throw underflow error
  - else pop element on top from stack1 and return
Time complexity : Enqueue operation takes O(n) + O (n) as it moves all the element twice. dequeue is o(1)
    
Approach2: Using 2 Stacks (Dequeue does the work of maitaining the LIFO pointers)
enqueue: 
 -push element to stack1
dequeue:
- If stack1 is empty && stack2 is empty - throw under flow error
- If stack1 is empty && stack2 is not empty - pop top element in stack2 and return
- else if stack1 is not empty && stack2 is empty 
  - push all elements from stack1 to stack2
  - pop the top element in stack2 and return it
Time complexity : Enqueue operation takes O(1). dequeue is o(1) and on worst cases O(n) where all elements are copied to stack2 from stack1.
    
Approach3: Using a user Stack and function call stack
enqueue:
push the element to stack1 -O(1)
Dequeue
Using function call stack we can store the current top element of the function call and recursively call the dequeue operation till we hit element at the bottom of stack and pop that element and return. Push the current call's top element back into stack1. - O(n) ( as we pop and push n-1 elements)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
5. Implement Stack using Queues:
Ask question : what are the elements in stack? Integer
               whether we need to implement Queue(we can use a LinkedList) or use Java datastructure queue (default is array)
approach : we need to reverse queue inorder implement LIFO. (but this makes push element difficult)
           we can have two queue.
           
           push is expensive
             - push(x) - O(n) time
               - add to q2 - this is the new top
               - if q1 is not empty - pop all elements from q1 to q2 and swap q1 with q2 (q1 has all elements and q2 is empty)
              
             - pop() - O(1) time
               - check if q1 is empty - throw underflow error
               - remove top element from q1
               
               public Stack<Integer>{
                  Queue<Integer> q1 = new Queue<>();
                  Queue<Integer> q2 = new Queue<>();
                  
                  push(Integer i){
                    q2.push(i);
                    while(!q1.isEmpty()){
                      q2.push(q1.pop());
                    }
                    Queue<Integer> temp = q1;
                    q1 = q2;
                    q2 = temp;
                  }
                  
                  int pop(){
                    if(q1.isEmpty()) throw "Underflow";
                    return q1.pop();
                  }
                 }
           pop is expensive
           enqueue -O(1)
            - push the element to Q1
           dequeue - o(n) time
            - if q1 is empty = throw an error
            - if not empty - move all elements except the last element from q1 to q2
               - pop the element from q1
               - swap q1 and q2
               - return the element popped from q1.
               
                public Stack<Integer>{
                  Queue<Integer> q1 = new Queue<>();
                  Queue<Integer> q2 = new Queue<>();
                  
                  push(Integer i){
                    q1.push(x);
                  }
                  
                  int pop(){
                    if(q1.isEmpty()) throw "Underflow";
                    else{
                      while(q1.size()!=1){
                        q2.push(q1.pop());
                      }
                      int temp = q1.pop(); //pop the last element in q1 after moving rest of the element to q2
                      Queue<Integer> q = q1;
                      q1=q2;
                      q2=q;
                      return temp;
                     }
                  }
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
6. Next Greater Element(NGE) for every element in a given array.
   Hints:
    - NGE of rightmost element in array is -1
    - NGE of all the element in an array sorted in descending order is -1.
    
   Approach1: 2 loop - o(n^2) time
    - Iterate the array from i = 0 to n-1 elements
      - Iterate the array from j= i+1 to n-2 elements
          - if a[i]<a[j] - print NGE of A[i] is a[j] and break inner loop
          - else continue to increment the j
      - print NGE of a[i] is -1 and increment the i.
    print NGE of a[n-1] is -1.
    
    Approach2: Using Stack 
    if the next value is not greater than current value we still search for next value that is greater than both previous and current value, using a stack to track the last and last before elements will be easy.
    - push the first element in the array to stack
    - iterate through the array for i =1 to n-1
       - check until the top element in stack is lesser than the current element in the array 
         - pop the top element in stack and print its NGE as current element and break the current
       - push the current element to stack( that becomes the new top) and i is incremented
    - if there are any elements left in stack (means that those elements does not have NGE) are printed as -1.
   
    
 

