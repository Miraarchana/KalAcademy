Week 2 - Stacks and Queues
Queue : FIFO
Stack : LIFO
 - Both can be implemented using array and linked list
 - No indexing, we can access only on top and bottom elements for queue and only top for stack

Check for implementing Queue using array in referencesource.microsoft.com for C#

Week 2 Assessments:
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
4. Implement Queue using Stacks

- for implementing Queue, enqueue must add element to the top of Stack and dequeue must remove element from bottom of stack.

Approach1: Using 2 Stacks (Enqueue does the work of maintaing the LIFO pointers)
enqueue:
  - If stack1 is empty- push element to stack1
  - If stack1 is not empty
    - copy all elements from stack1 to stack2
    - push new element to stack1
    - push all elements back from stack2 to stack1
dequeue:
  - If stack1 is empty - throw underflow error
  - else pop element on top from stack1 and return
Time complexity : Enqueue operation takes O(n) + O (n) as it moves all the element twice. dequeue is o(1)
    
Approach2: Using 2 Stacks (Dequeue does the work of maitaining the LIFO pointers)
enqueue: 
 -push element to stack1
dequeue:
- If stack1 is empty && stack2 is empty - throw under flow error
- If stack1 is empty && stack2 is not empty - pop top element in stack2 and return
- else if stack1 is not empty && stack2 is empty 
  - push all elements from stack1 to stack2
  - pop the top element in stack2 and return it
Time complexity : Enqueue operation takes O(1). dequeue is o(1) and on worst cases O(n) where all elements are copied to stack2 from stack1.
    
Approach3: Using a user Stack and function call stack
enqueue:
push the element to stack1 -O(1)
Dequeue
Using function call stack we can store the current top element of the function call and recursively call the dequeue operation till we hit element at the bottom of stack and pop that element and return. Push the current call's top element back into stack1. - O(n) ( as we pop and push n-1 elements)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
5. Implement Stack using Queues:
Ask question : what are the elements in stack? Integer
               whether we need to implement Queue(we can use a LinkedList) or use Java datastructure queue (default is array)
approach : we need to reverse queue inorder implement LIFO. (but this makes push element difficult)
           we can have two queue.
           
           push is expensive
             - push(x) - O(n) time
               - add to q2 - this is the new top
               - if q1 is not empty - pop all elements from q1 to q2 and swap q1 with q2 (q1 has all elements and q2 is empty)
              
             - pop() - O(1) time
               - check if q1 is empty - throw underflow error
               - remove top element from q1
               
               public Stack<Integer>{
                  Queue<Integer> q1 = new Queue<>();
                  Queue<Integer> q2 = new Queue<>();
                  
                  push(Integer i){
                    q2.push(i);
                    while(!q1.isEmpty()){
                      q2.push(q1.pop());
                    }
                    Queue<Integer> temp = q1;
                    q1 = q2;
                    q2 = temp;
                  }
                  
                  int pop(){
                    if(q1.isEmpty()) throw "Underflow";
                    return q1.pop();
                  }
                 }
           pop is expensive
           enqueue -O(1)
            - push the element to Q1
           dequeue - o(n) time
            - if q1 is empty = throw an error
            - if not empty - move all elements except the last element from q1 to q2
               - pop the element from q1
               - swap q1 and q2
               - return the element popped from q1.
               
                public Stack<Integer>{
                  Queue<Integer> q1 = new Queue<>();
                  Queue<Integer> q2 = new Queue<>();
                  
                  push(Integer i){
                    q1.push(x);
                  }
                  
                  int pop(){
                    if(q1.isEmpty()) throw "Underflow";
                    else{
                      while(q1.size()!=1){
                        q2.push(q1.pop());
                      }
                      int temp = q1.pop(); //pop the last element in q1 after moving rest of the element to q2
                      Queue<Integer> q = q1;
                      q1=q2;
                      q2=q;
                      return temp;
                     }
                  }
             

